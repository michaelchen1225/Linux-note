# 壓縮、打包、備份

## 壓縮原理

目前的電腦系統中都是使用 `bytes` 為計量單位的，但事實上電腦最小的計量單位應該是 `bits`，這就可能產生儲存上的「多餘空間」。

舉例來說，如果今天我們只是記憶一個數字，假設是數字 1，但 1 本身只占用 1 個 bit 的空間，但電腦的計量單位卻用 bytes(8 bits) 來計算，這樣就會產生「多餘空間」的問題：

```text
00000001
```

上面那七個 0 就是多餘的空間了！而一些聰明的電腦工程師就利用一些複雜的計算方式， 將這些沒有使用到的空間『丟』出來，以讓檔案佔用的空間變小，這就是壓縮的技術！

另外一種壓縮技術也很有趣，他是將重複的資料進行統計記錄的。舉例來說，若資料為「111....」有100個1時， 那麼壓縮技術會記錄為「100個1」，而不是真的有100個1的位元存在，這樣也能夠精簡檔案記錄的容量！

簡單的說，「壓縮」的概念可以想成：

> 檔案裡面有相當多的「空間」存在，並不是完全填滿的， 而「壓縮」的技術就是將這些「空間」填滿，以讓整個檔案佔用的容量下降！ 

不過，這些壓縮檔無法直接被我們的作業系統所使用的，因此必須將他「還原」回未壓縮的模樣， 就是所謂的「解壓縮」。


### 壓縮的好處

* 減少檔案占用的硬碟空間

* 減少網路傳輸時佔用的頻寬

  > 目前很多 www 網頁都會將網頁內容進行壓縮，到你電腦時再解壓縮。這有賴於現在 CPU 的運算很快，因此解壓縮的時間極少，我們能感受到的等待時間其實是在「資料傳輸」的時間！


### 打包？打包 v.s 壓縮？

有時會聽到「打包」這個詞，剛開始可能會和「壓縮」搞混，實際上是有差別的：

* 壓縮：針對「單一」檔案的內容進行壓縮，讓 size 變小。
* 打包：是將多個檔案、甚至目錄包成成一個檔案，但不會經過壓縮，所以打包檔反而會比原本的檔案大。

那為什麼要打包呢？因為 Linux 中的壓縮指令大多無法直接壓縮目錄，如果每個目錄中的檔案都要一個個壓縮很麻煩。常見的做法是先把目錄打包成一個檔案，然後針對「打包檔」進行壓縮。


## Linux 常見的壓縮副檔名

首先得先知道：Linux 的副檔名實際不會影響任何「功能」，只是讓我們更容易辨識檔案類別而已。

> 舉例而言，你在 Windows 上把純文字檔 `.txt` 改成 `.jpg`，那麼這個檔案就會變成一個圖片檔，會打不開。但在 Linux 中，只要檔案**本身**的內容是純文字，就算你把它改成 `.jpg`，它還是純文字檔。

Linux 中有多種壓縮指令，差別主要在於壓縮的原理 or 壓縮比等等，用法其實大同小異。為了「區分」是哪種指令形成的壓縮檔，壓縮檔的結尾會被「壓所指令」加上不同的副檔名：

| 副檔名 | 指令 |
|--------|----------|
| .Z | compress | 
| .zip | zip | 
| .gz | gzip |
| .bz2 | bzip2 |
| xz | xz |
| .tar | tar(打包非壓縮) |
| .tar.gz | 先打包再壓縮(tar + gzip) |
| .tgz | 同上，只是寫法不同 |
| .tar.bz2 | 先打包再壓縮(tar + bzip2) |
| .tar.xz | 先打包再壓縮(tar + xz) |

以上常見的壓縮指令是 gzip, bzip2 以及 xz ，至於 compress 已經退流行了(被 gzip 取代)。

```
壓縮比：xz > bzip2 > gzip
壓縮速度：gzip > bzip2 > xz
```
> 不趕時間、追求壓縮比的話，建議使用 xz；如果不想等太久，建議使用 gzip。

至於 tar 則是打包指令，一開始的功能僅是「打包」而已，並沒有提供壓縮的功能。後來，GNU 計畫將整個 tar 與壓縮的功能結合在一起，提供使用者更方便的壓縮與打包功能！底下我們就來分析這些指令的用法。

## gzip 系列：gzip, zcat/zmore/zless/zgrep

語法：

```
gzip [-cdtv#] <檔案>
zcat <檔名>.gz
```

| Option | 說明 |
|--------|----------|
| -c | 將壓縮檔的內容輸出到標準輸出，有利於管線處理 |
| -d | 解壓縮檔案 |
| -t | 測試壓縮檔是否正確 |
| -v | 顯示詳細的壓縮過程 |
| -# | 壓縮等級，1~9，數字越大壓縮比越高，但速度越慢，預設為 6 |

**範例**：找出 /etc 底下 (不含子目錄) 容量最大的檔案，並將它複製到 /tmp ，然後以 gzip 壓縮

```bash
ls -ldSrh /etc/* | tail -n 1 
```
```
-rw-r--r-- 1 root root       74K Jul 12  2023 /etc/mime.types
```

```bash
cp /etc/mime.types /tmp
gzip -v /tmp/mime.types
```
```
/tmp/mime.types:         73.1% -- replaced with /tmp/mime.types.gz
```
> 這裡的 73.1% 代表壓縮後會少 54K (74K * 73.1% = 54K)，因此最終壓縮檔的大小會是 20K。

```bash
# 比較前後的檔案大小 
ls -lh /etc/mime.types /tmp/mime.types*
```
```
-rw-r--r-- 1 root root 74K Jul 12  2023 /etc/mime.types
-rw-r--r-- 1 root root 20K Apr 29 09:18 /tmp/mime.types.gz
```

需要特別注意，原始檔案(/tmp/mime.types)會直接被壓縮檔取代！那該如何保留原檔？這得使用 `-c` 與「資料流重導」的概念：


**範例**：壓縮並保留原檔

```bash
# 由於原檔被取代了，我們在複製一份過來
cp /etc/mime.types /tmp
```
```bash
gzip -c /tmp/mime.types > /tmp/mime.types.gz
```
```bash
ls -lh /etc/mime.types /tmp/mime.types*
```
```
-rw-r--r-- 1 root root 74K Jul 12  2023 /etc/mime.types
-rw-r--r-- 1 root root 74K Apr 29 09:41 /tmp/mime.types
-rw-r--r-- 1 root root 20K Apr 29 09:41 /tmp/mime.types.gz
```

在 ls 的輸出中可以看到原始檔成功保留了！

在 gzip 加上 `-c`後，就不會形成壓縮檔，而只是將壓縮後的內容丟到標準輸出(stdout)，這解決了「壓縮檔取代原始檔」的問題。但我們最終目的仍是壓縮檔，因此用 `>` 將 stdout 中的「壓縮內容」導入我們自訂的檔名 `/tmp/mime.types.gz` 中。

> 如果看不懂，現在可以先執行 `gzip -c /tmp/mime.types` 然後再 `cat /tmp/mine.types.gz`，就會發現兩者呈現的亂碼是相同的，就能比較直觀的理解「資料重導向」的概念了。

**範例**：讀取壓縮檔的內容

壓縮後的檔案用一般的 `cat` 指令會讀出亂碼，必須使用 `zcat` 指令來讀取壓縮檔的內容。

```bash
zcat /tmp/mime.types.gz
```

舉一反三，`zmore`、`zless`、`zgrep` 也可以用來處理壓縮檔的原始內容，這些指令的用法和 `more`、`less`、`grep` 一樣，只是多了一個 `z` 而已。

**範例**：用 more 的方式閱讀原始內容

```bash
zmore /tmp/mime.types.gz 
```

**範例**：在壓縮檔中尋找關鍵字 "csv"，並顯示行號

```bash
zgrep -n "csv" /tmp/mime.types.gz
```


